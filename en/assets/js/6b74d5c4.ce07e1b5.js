"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3328],{8531:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var r=e(5893),i=e(1151);const a={sidebar_position:3},s="Linux 4.9 \u5185\u6838\u9002\u914d",o={id:"TinyVision/part8/Linux4.9KernelAdaptation",title:"Linux 4.9 \u5185\u6838\u9002\u914d",description:"\u9a71\u52a8\u52fe\u9009",source:"@site/docs/TinyVision/part8/3-Linux4.9KernelAdaptation.md",sourceDirName:"TinyVision/part8",slug:"/TinyVision/part8/Linux4.9KernelAdaptation",permalink:"/en/docs/TinyVision/part8/Linux4.9KernelAdaptation",draft:!1,unlisted:!1,editUrl:"https://github.com/100askTeam/linuxboard-docs/tree/main/docs/TinyVision/part8/3-Linux4.9KernelAdaptation.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"v851seSidebar",previous:{title:"Linux 5.15 \u5185\u6838\u9002\u914d",permalink:"/en/docs/TinyVision/part8/Linux5.15KernelAdaptation"},next:{title:"\u663e\u793a Linux \u7ec8\u7aef",permalink:"/en/docs/TinyVision/part8/DisplayLinuxTerminal"}},p={},l=[{value:"\u9a71\u52a8\u52fe\u9009",id:"\u9a71\u52a8\u52fe\u9009",level:3},{value:"\u52fe\u9009 SPI \u9a71\u52a8",id:"\u52fe\u9009-spi-\u9a71\u52a8",level:3},{value:"\u52fe\u9009 Linux FrameBuffer \u9a71\u52a8",id:"\u52fe\u9009-linux-framebuffer-\u9a71\u52a8",level:3},{value:"\u9002\u914d FBTFT \u7684\u8bbe\u5907\u6811\u63a5\u53e3",id:"\u9002\u914d-fbtft-\u7684\u8bbe\u5907\u6811\u63a5\u53e3",level:3},{value:"\u7f16\u5199\u914d\u5957\u5c4f\u5e55 ST7789v \u9a71\u52a8",id:"\u7f16\u5199\u914d\u5957\u5c4f\u5e55-st7789v-\u9a71\u52a8",level:3},{value:"\u7f16\u5199\u8bbe\u5907\u6811",id:"\u7f16\u5199\u8bbe\u5907\u6811",level:3}];function c(t){const n={code:"code",h1:"h1",h3:"h3",img:"img",p:"p",pre:"pre",...(0,i.a)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"linux-49-\u5185\u6838\u9002\u914d",children:"Linux 4.9 \u5185\u6838\u9002\u914d"}),"\n",(0,r.jsx)(n.h3,{id:"\u9a71\u52a8\u52fe\u9009",children:"\u9a71\u52a8\u52fe\u9009"}),"\n",(0,r.jsx)(n.p,{children:"\u7531\u4e8e\u4f7f\u7528\u7684\u662f SPI0\uff0c\u6240\u4ee5 TinyVision \u7684 LCD \u6a21\u5757\u5e76\u4e0d\u652f\u6301\u4f7f\u7528MIPI-DBI\u8fdb\u884c\u9a71\u52a8\uff0c\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528\u666e\u901a\u7684SPI\u6a21\u62df\u65f6\u5e8f\u3002"}),"\n",(0,r.jsx)(n.h3,{id:"\u52fe\u9009-spi-\u9a71\u52a8",children:"\u52fe\u9009 SPI \u9a71\u52a8"}),"\n",(0,r.jsxs)(n.p,{children:["\u8fd9\u91cc\u6211\u4eec\u4f7f\u7528 SPI-NG \u9a71\u52a8\uff0c\u52fe\u9009 ",(0,r.jsx)(n.code,{children:"Device Drivers  ---\x3e [*] SPI support  ---\x3e<*>   SUNXI SPI Controller"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"image-20240320180743441",src:e(2016).Z+"",width:"1282",height:"774"})}),"\n",(0,r.jsx)(n.h3,{id:"\u52fe\u9009-linux-framebuffer-\u9a71\u52a8",children:"\u52fe\u9009 Linux FrameBuffer \u9a71\u52a8"}),"\n",(0,r.jsx)(n.p,{children:"\u524d\u5f80\u5982\u4e0b\u5730\u5740\uff0c\u52fe\u9009\u9a71\u52a8"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Device Drivers  ---\x3e\n\tGraphics support  ---\x3e\n\t\tFrame buffer Devices  ---\x3e\n\t\t\t<*> Support for frame buffer devices\n\t\tConsole display driver support  ---\x3e\n\t\t\t[*] Framebuffer Console support\n\t\t\t[*]   Map the console to the primary display device\n\t[*] Staging drivers  ---\x3e\n\t\t<*>   Support for small TFT LCD display modules  ---\x3e\n\t\t<*>   FB driver for the ST7789V LCD Controller\n"})}),"\n",(0,r.jsx)(n.h3,{id:"\u9002\u914d-fbtft-\u7684\u8bbe\u5907\u6811\u63a5\u53e3",children:"\u9002\u914d FBTFT \u7684\u8bbe\u5907\u6811\u63a5\u53e3"}),"\n",(0,r.jsxs)(n.p,{children:["\u8fdb\u5165\u5185\u6838\u6587\u4ef6\u5939\uff0c\u627e\u5230 ",(0,r.jsx)(n.code,{children:"lichee/linux-4.9/drivers/staging/fbtft/fbtft-core.c"})]}),"\n",(0,r.jsx)(n.p,{children:"\u6dfb\u52a0\u5934\u6587\u4ef6"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"#include <linux/sunxi-gpio.h>\n"})}),"\n",(0,r.jsx)(n.p,{children:"\u4fee\u6539\u9a71\u52a8\u6ce8\u518c\u63a5\u53e3"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'static int fbtft_request_one_gpio(struct fbtft_par *par,\n\t\t\t\t  const char *name, int index, int *gpiop)\n{\n\tstruct device *dev = par->info->device;\n\tstruct device_node *node = dev->of_node;\n\tint gpio, flags, ret = 0;\n\tstruct gpio_config gpio_of_flags;\n\n\tif (of_find_property(node, name, NULL)) {\n\t\tgpio = of_get_named_gpio_flags(node, name, index, (enum of_gpio_flags *)&gpio_of_flags);\n\t\tif (gpio == -ENOENT)\n\t\t\treturn 0;\n\t\tif (gpio == -EPROBE_DEFER)\n\t\t\treturn gpio;\n\t\tif (gpio < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t"failed to get \'%s\' from DT\\n", name);\n\t\t\treturn gpio;\n\t\t}\n\n\t\t/* active low translates to initially low */\n\t\tflags = (gpio_of_flags.data & OF_GPIO_ACTIVE_LOW) ? GPIOF_OUT_INIT_LOW :\n\t\t\t\t\t\t\tGPIOF_OUT_INIT_HIGH;\n\t\tret = devm_gpio_request_one(dev, gpio, flags,\n\t\t\t\t\t\tdev->driver->name);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t"gpio_request_one(\'%s\'=%d) failed with %d\\n",\n\t\t\t\tname, gpio, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (gpiop)\n\t\t\t*gpiop = gpio;\n\t\tfbtft_par_dbg(DEBUG_REQUEST_GPIOS, par, "%s: \'%s\' = GPIO%d\\n",\n\t\t\t\t\t\t\t__func__, name, gpio);\n\t}\n\treturn ret;\n}\n\nstatic int fbtft_request_gpios_dt(struct fbtft_par *par)\n{\n\tint i;\n\tint ret;\n\n\tif (!par->info->device->of_node)\n\t\treturn -EINVAL;\n\n\tret = fbtft_request_one_gpio(par, "reset", 0, &par->gpio.reset);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, "dc", 0, &par->gpio.dc);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, "rd", 0, &par->gpio.rd);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, "wr", 0, &par->gpio.wr);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, "cs", 0, &par->gpio.cs);\n\tif (ret)\n\t\treturn ret;\n\tret = fbtft_request_one_gpio(par, "latch", 0, &par->gpio.latch);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < 16; i++) {\n\t\tret = fbtft_request_one_gpio(par, "db", i,\n\t\t\t\t\t\t&par->gpio.db[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fbtft_request_one_gpio(par, "led", i,\n\t\t\t\t\t\t&par->gpio.led[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fbtft_request_one_gpio(par, "aux", i,\n\t\t\t\t\t\t&par->gpio.aux[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"\u7f16\u5199\u914d\u5957\u5c4f\u5e55-st7789v-\u9a71\u52a8",children:"\u7f16\u5199\u914d\u5957\u5c4f\u5e55 ST7789v \u9a71\u52a8"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:'/*\n * FB driver for the ST7789V LCD Controller\n *\n * Copyright (C) 2015 Dennis Menschel\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n */\n\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gpio.h>\n#include <video/mipi_display.h>\n\n#include "fbtft.h"\n\n#define DRVNAME "fb_st7789v"\n\n#define DEFAULT_GAMMA \\\n\t"70 2C 2E 15 10 09 48 33 53 0B 19 18 20 25\\n" \\\n\t"70 2C 2E 15 10 09 48 33 53 0B 19 18 20 25"\n\n#define HSD20_IPS_GAMMA \\\n\t"D0 05 0A 09 08 05 2E 44 45 0F 17 16 2B 33\\n" \\\n\t"D0 05 0A 09 08 05 2E 43 45 0F 16 16 2B 33"\n\n/**\n * enum st7789v_command - ST7789V display controller commands\n *\n * @PORCTRL: porch setting\n * @GCTRL: gate control\n * @VCOMS: VCOM setting\n * @VDVVRHEN: VDV and VRH command enable\n * @VRHS: VRH set\n * @VDVS: VDV set\n * @VCMOFSET: VCOM offset set\n * @PWCTRL1: power control 1\n * @PVGAMCTRL: positive voltage gamma control\n * @NVGAMCTRL: negative voltage gamma control\n *\n * The command names are the same as those found in the datasheet to ease\n * looking up their semantics and usage.\n *\n * Note that the ST7789V display controller offers quite a few more commands\n * which have been omitted from this list as they are not used at the moment.\n * Furthermore, commands that are compliant with the MIPI DCS have been left\n * out as well to avoid duplicate entries.\n */\nenum st7789v_command {\n\tPORCTRL = 0xB2,\n\tGCTRL = 0xB7,\n\tVCOMS = 0xBB,\n\tVDVVRHEN = 0xC2,\n\tVRHS = 0xC3,\n\tVDVS = 0xC4,\n\tVCMOFSET = 0xC5,\n\tPWCTRL1 = 0xD0,\n\tPVGAMCTRL = 0xE0,\n\tNVGAMCTRL = 0xE1,\n};\n\n#define MADCTL_BGR BIT(3) /* bitmask for RGB/BGR order */\n#define MADCTL_MV BIT(5) /* bitmask for page/column order */\n#define MADCTL_MX BIT(6) /* bitmask for column address order */\n#define MADCTL_MY BIT(7) /* bitmask for page address order */\n\n/**\n * init_display() - initialize the display controller\n *\n * @par: FBTFT parameter object\n *\n * Most of the commands in this init function set their parameters to the\n * same default values which are already in place after the display has been\n * powered up. (The main exception to this rule is the pixel format which\n * would default to 18 instead of 16 bit per pixel.)\n * Nonetheless, this sequence can be used as a template for concrete\n * displays which usually need some adjustments.\n *\n * Return: 0 on success, < 0 if error occurred.\n */\nstatic int init_display(struct fbtft_par *par)\n{\n    par->fbtftops.reset(par);\n    mdelay(50);\n    write_reg(par,0x36,0x00);\n    write_reg(par,0x3A,0x05);\n    write_reg(par,0xB2,0x1F,0x1F,0x00,0x33,0x33);\n    write_reg(par,0xB7,0x35);\n    write_reg(par,0xBB,0x20);\n    write_reg(par,0xC0,0x2C);\n    write_reg(par,0xC2,0x01);\n    write_reg(par,0xC3,0x01);\n    write_reg(par,0xC4,0x18);\n    write_reg(par,0xC6,0x13);\n    write_reg(par,0xD0,0xA4,0xA1);\n    write_reg(par,0xE0,0xF0,0x04,0x07,0x04,0x04,0x04,0x25,0x33,0x3C,0x36,0x14,0x12,0x29,0x30);\n    write_reg(par,0xE1,0xF0,0x02,0x04,0x05,0x05,0x21,0x25,0x32,0x3B,0x38,0x12,0x14,0x27,0x31);\n    write_reg(par,0xE4,0x1D,0x00,0x00);\n\twrite_reg(par,0x21);\n    write_reg(par,0x11);\n    mdelay(50);\n    write_reg(par,0x29);\n    mdelay(200);\n    return 0;\n\treturn 0;\n}\n\n/**\n * set_var() - apply LCD properties like rotation and BGR mode\n *\n * @par: FBTFT parameter object\n *\n * Return: 0 on success, < 0 if error occurred.\n */\nstatic int set_var(struct fbtft_par *par)\n{\n\tu8 madctl_par = 0;\n\n\tif (par->bgr)\n\t\tmadctl_par |= MADCTL_BGR;\n\tswitch (par->info->var.rotate) {\n\tcase 0:\n\t\tbreak;\n\tcase 90:\n\t\tmadctl_par |= (MADCTL_MV | MADCTL_MY);\n\t\tbreak;\n\tcase 180:\n\t\tmadctl_par |= (MADCTL_MX | MADCTL_MY);\n\t\tbreak;\n\tcase 270:\n\t\tmadctl_par |= (MADCTL_MV | MADCTL_MX);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\twrite_reg(par, MIPI_DCS_SET_ADDRESS_MODE, madctl_par);\n\treturn 0;\n}\n\n/**\n * set_gamma() - set gamma curves\n *\n * @par: FBTFT parameter object\n * @curves: gamma curves\n *\n * Before the gamma curves are applied, they are preprocessed with a bitmask\n * to ensure syntactically correct input for the display controller.\n * This implies that the curves input parameter might be changed by this\n * function and that illegal gamma values are auto-corrected and not\n * reported as errors.\n *\n * Return: 0 on success, < 0 if error occurred.\n */\nstatic int set_gamma(struct fbtft_par *par, unsigned long *curves)\n{\n\tint i;\n\tint j;\n\tint c; /* curve index offset */\n\n\t/*\n\t * Bitmasks for gamma curve command parameters.\n\t * The masks are the same for both positive and negative voltage\n\t * gamma curves.\n\t */\n\tconst u8 gamma_par_mask[] = {\n\t\t0xFF, /* V63[3:0], V0[3:0]*/\n\t\t0x3F, /* V1[5:0] */\n\t\t0x3F, /* V2[5:0] */\n\t\t0x1F, /* V4[4:0] */\n\t\t0x1F, /* V6[4:0] */\n\t\t0x3F, /* J0[1:0], V13[3:0] */\n\t\t0x7F, /* V20[6:0] */\n\t\t0x77, /* V36[2:0], V27[2:0] */\n\t\t0x7F, /* V43[6:0] */\n\t\t0x3F, /* J1[1:0], V50[3:0] */\n\t\t0x1F, /* V57[4:0] */\n\t\t0x1F, /* V59[4:0] */\n\t\t0x3F, /* V61[5:0] */\n\t\t0x3F, /* V62[5:0] */\n\t};\n\n\tfor (i = 0; i < par->gamma.num_curves; i++) {\n\t\tc = i * par->gamma.num_values;\n\t\tfor (j = 0; j < par->gamma.num_values; j++)\n\t\t\tcurves[c + j] &= gamma_par_mask[j];\n\t\twrite_reg(\n\t\t\tpar, PVGAMCTRL + i,\n\t\t\tcurves[c + 0], curves[c + 1], curves[c + 2],\n\t\t\tcurves[c + 3], curves[c + 4], curves[c + 5],\n\t\t\tcurves[c + 6], curves[c + 7], curves[c + 8],\n\t\t\tcurves[c + 9], curves[c + 10], curves[c + 11],\n\t\t\tcurves[c + 12], curves[c + 13]);\n\t}\n\treturn 0;\n}\n\n/**\n * blank() - blank the display\n *\n * @par: FBTFT parameter object\n * @on: whether to enable or disable blanking the display\n *\n * Return: 0 on success, < 0 if error occurred.\n */\nstatic int blank(struct fbtft_par *par, bool on)\n{\n\tif (on)\n\t\twrite_reg(par, MIPI_DCS_SET_DISPLAY_OFF);\n\telse\n\t\twrite_reg(par, MIPI_DCS_SET_DISPLAY_ON);\n\treturn 0;\n}\n\nstatic void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)\n{\n\tswitch(par->info->var.rotate)\n\t{\n\t\tcase   0: \n\t\t\tbreak;\n \t\tcase  90: \n\t\t\txs+=80;xe+=80;\n\t\t\tbreak;\n\t \tcase 180:\n\t \t\tbreak;\n\t \tcase 270: \n\t\t\txs+=80;xe+=80;\n\t \t\tbreak;\n\t \tdefault :\n\t\t\tbreak;\n\t}\n\twrite_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,\n\t\t  (xs >> 8) & 0xFF, xs & 0xFF, (xe >> 8) & 0xFF, xe & 0xFF);\n\n\twrite_reg(par, MIPI_DCS_SET_PAGE_ADDRESS,\n\t\t  (ys >> 8) & 0xFF, ys & 0xFF, (ye >> 8) & 0xFF, ye & 0xFF);\n\n\twrite_reg(par, MIPI_DCS_WRITE_MEMORY_START);\n}\n\nstatic void reset(struct fbtft_par *par)\n{\n\tif (par->gpio.reset == -1)\n\t\treturn;\n\tfbtft_par_dbg(DEBUG_RESET, par, "%s()\\n", __func__);\n\tgpio_set_value(par->gpio.reset, 1);\n\tmdelay(20);\n\tgpio_set_value(par->gpio.reset, 0);\n\tmdelay(20);\n\tgpio_set_value(par->gpio.reset, 1);\n\tmdelay(120);\n}\n\nstatic struct fbtft_display display = {\n\t.regwidth = 8,\n\t.width = 240,\n\t.height = 240,\n\t.gamma_num = 2,\n\t.gamma_len = 14,\n\t.gamma = HSD20_IPS_GAMMA,\n\t.fbtftops = {\n\t\t.init_display = init_display,\n\t\t.set_addr_win = set_addr_win,\n\t\t.set_var = set_var,\n\t\t.set_gamma = set_gamma,\n\t\t.blank = blank,\n\t\t.reset = reset,\n\t},\n};\n\nFBTFT_REGISTER_DRIVER(DRVNAME, "sitronix,st7789v", &display);\n\nMODULE_ALIAS("spi:" DRVNAME);\nMODULE_ALIAS("platform:" DRVNAME);\nMODULE_ALIAS("spi:st7789v");\nMODULE_ALIAS("platform:st7789v");\n\nMODULE_DESCRIPTION("FB driver for the ST7789V LCD Controller");\nMODULE_AUTHOR("Dennis Menschel");\nMODULE_LICENSE("GPL");\n'})}),"\n",(0,r.jsx)(n.h3,{id:"\u7f16\u5199\u8bbe\u5907\u6811",children:"\u7f16\u5199\u8bbe\u5907\u6811"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'&pio {\n\tspi0_pins_a: spi0@0 {\n\t\tallwinner,pins = "PC0", "PC2", "PC3";\n\t\tallwinner,pname = "spi0_sclk", "spi0_mosi", "spi0_miso";\n\t\tallwinner,function = "spi0";\n\t\tallwinner,muxsel = <4>;\n\t\tallwinner,drive = <1>;\n\t\tallwinner,pull = <0>;\n\t};\n\n\tspi0_pins_b: spi0@1 {\n\t\tallwinner,pins = "PC1", "PC5", "PC4";\n\t\tallwinner,pname = "spi0_cs0", "spi0_hold", "spi0_wp";\n\t\tallwinner,function = "spi0";\n\t\tallwinner,muxsel = <4>;\n\t\tallwinner,drive = <1>;\n\t\tallwinner,pull = <1>;   // only CS should be pulled up\n\t};\n\n\tspi0_pins_c: spi0@2 {\n\t\tallwinner,pins = "PC0", "PC1", "PC2", "PC3", "PC4", "PC5";\n\t\tallwinner,function = "io_disabled";\n\t\tallwinner,muxsel = <7>;\n\t\tallwinner,drive = <1>;\n\t\tallwinner,pull = <0>;\n\t};\n\n\tspi0_pins_lcd: spi0@3 {\n\t\tallwinner,pins = "PC0", "PC2"; /* clk, mosi */\n\t\tallwinner,function = "spi0";\n\t\tallwinner,muxsel = <4>;\n\t\tallwinner,drive = <1>;\n\t\tallwinner,pull = <0>;\n\t};\n\n\tspi0_pins_lcd_cs: spi0@4 {\n\t\tallwinner,pins = "PC1"; /* cs */\n\t\tallwinner,function = "spi0";\n\t\tallwinner,muxsel = <4>;\n\t\tallwinner,pull = <1>;\n\t\tallwinner,drive = <1>;\n\t};\n};\n\n&spi0 {\n\tclock-frequency = <100000000>;\n\tpinctrl-0 = <&spi0_pins_lcd &spi0_pins_lcd_cs>;\n\tpinctrl-1 = <&spi0_pins_c>;\n\tpinctrl-names = "default", "sleep";\n\tspi_slave_mode = <0>;\n\tspi_dbi_enable = <0>;\n\tspi0_cs_number = <1>;\n\tstatus = "okay";\n\n\tst7789v@0 {\n    \tstatus = "okay";\n    \tcompatible = "sitronix,st7789v";\n\t\treg = <0>;\n\t\tspi-max-frequency = <30000000>;\n\t\trotate = <0>;\n\t\tbgr;\n\t\tfps = <30>;\n\t\tbuswidth = <8>;\n\t\treset = <&pio PC 5 1 1 2 1>;\n\t\tdc = <&pio PC 4 1 1 2 0>;\n\t\tdebug = <1>;\n\t};\n};\n'})})]})}function d(t={}){const{wrapper:n}={...(0,i.a)(),...t.components};return n?(0,r.jsx)(n,{...t,children:(0,r.jsx)(c,{...t})}):c(t)}},2016:(t,n,e)=>{e.d(n,{Z:()=>r});const r=e.p+"assets/images/image-20240320180743441-4ebdde5d4cd407a092b087059f1b5fd8.png"},1151:(t,n,e)=>{e.d(n,{Z:()=>o,a:()=>s});var r=e(7294);const i={},a=r.createContext(i);function s(t){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function o(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(i):t.components||i:s(t.components),r.createElement(a.Provider,{value:n},t.children)}}}]);